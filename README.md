# 伊辛模型的构型空间渗流(Percolation in the configuration space of Ising model)

## 算法

伊辛模型的模拟是统计物理中计算方法的范例，对于各种算法和计算各种物理量都有了非常详尽的资料，因此这里略过这部分讨论。需要额外注意的一点是，由于本文中需要大量的平衡态采样，并且所采样的平衡态之间的关联性对于最后计算结果会产生重大的影响。因此需要注意wolff算法的关联时间问题，以及在高于临界温度和低于临界温度情形下的区别。

程序的重点是对构型空间网络的构建和对$\Delta$的计算。本文中的模拟使用C++进行实现。计算的方案可以主要分为
1. 采样；
2. 计算两两构型之间的距离；
3. 将所有距离进行排序；
4. 按照距离从小到大进行加边；
5. 计算相应物理量，主要是最大团尺寸。

其中，第1步是通过伊辛模型模拟解决。第3步则通过简单的排序算法，如快速排序，即可实现。

第4步和第5步主要参考了 [Fast Monte Carlo algorithm for site or bond percolation](https://journals.aps.org/pre/abstract/10.1103/PhysRevE.64.016706) 这篇文章中实现在逐渐加边的过程中快速计算最大团尺寸的方法。具体操作是采用了计算机科学中树结构的方法来记录团簇，并且使用递归的方法，实现了对每个节点的根节点坐标的快速更新，使得通过任何一个点都能迅速的找到其根节点从而获得当前节点所在团的大小。由于每一次加边只改变两个团的大小(如果把单个点也看作大小为1的团)或者不改变任何团大小，所以经过很容易的比较就可以得到此时最大团所包含的点数。而在此基础上，经过简单的修改，就能够计算次大团，以及其他级别大小团的尺寸。

在此基础之上，经过实际运行程序，发现开销最大的部分，其实是第2步。假设我们总共获得了$N$个样本，伊辛模型总的格点数为$k$，那么为了计算两两之间的距离，计算的复杂度是$O(N^2k)$。这是一个很大的复杂度，特别是在这种需要大量采样的算法下，$N$和$k$往往会同时比较大。

对此，解决的办法是
- 优化距离算法
- 采用随机网络蒙特卡罗的方法

先来讨论第一点，优化距离的计算。普通的距离计算公式为
$$	r = \sqrt{(x_1-y_1)^2+(x_2-y_2)^2+ \cdots +(x_k-y_k)^2}$$
由于对于伊辛模型，每一个格点都只有两种状态，而在程序中，分别被记为$1$和$-1$。因此，将所有样本看做$k$维矢量，那么其模长全都相等，均为$\sqrt{k}$。此时，我们可以通过內积来替代距离，在互相比较的情况下，內积与距离关系恰好完全相反
$$	r = x_1y_1+x_2y_2 + \cdots +x_ky_k$$

又由于是伊辛模型，每一个格点只有两种状态，这与二进制相互对应。因此，对于內积的运算，可以使用位运算来进行加速。具体方法是，对于每一个样本(一个长度为k的元素全为1和-1的数组)，可以将其以64个为一个单位，按照1对应1，-1对应0的规则，翻译成一个占据内存为64位的无符号长整型数。从而将样本转化一个元素均为64位长整型的数组。对于计算內积，则转化为进行异或运算，然后统计结果的二进制数中1的个数。这样的位运算方法能够对內积运算进行十分有效的加速。

但是，对于距离计算的优化，始终没有解决拖累程序运行的关键，就是$O(N^2k)$的计算复杂度。同时，考虑整个加边过程中团的变化，就会发现，以低温为例，由于两个较大集团初始距离较远，那么开始加边时主要是在两个集团内部加边，大概加完总变数一半时，会将两个大集团进行连接，此时的最大团改变量就是我们关心的$\Delta$。但是，这个过程中实际上有许多没有意义的过程。因为如果你只满足于构建一个团，那么所需要边数其实并不多，往往只需要几倍于总节点数的边数。而程序中大部分的加边，其实根本不能改变团块的尺寸，往往是团内部节点之间的互相连接。虽然加边本身开销不大，但是为了加这些边所需的距离计算却占了主要的开销，并且实际上这种距离计算并没有意义。

因此，为了规避这些大量冗余的距离计算，需要采取全新的算法，也就是之前提到的随机网络蒙特卡罗的方法。我们首先固定想要选取的边数，为了能够体现出团的尺寸特征，这个数额与样本数$N$只需要是线性关系，根据随机网络的相关结论，$10N$至$20N$的边数已经能够满足我们的要求。固定好选取的边数之后，随机从所有可能的连边中选取，之后按照相同的过程计算距离，排序，加边和计算$\Delta$。由于引入了一定的随机性，我们可以对一组样本进行一定次数的重复，最终取平均结果。

这种方法的优越性在于，我们将距离计算的复杂度从$O(N^2k)$降到了$O(Nk)$，当样本数$N$较大时，能够特别显著的提升计算速度。

此外，由于蒙特卡罗方法采样本身就带有很大的随机性，计算$\Delta$的误差往往很大，需要经过多次计算求平均来减小误差。因此，采用并行计算对获取较精确结果也是必不可少的。在研究过程中，还发现了使用GPU和CUDA能够更加快速的进行伊辛模型的计算，但由于时间和技术原因，此处并无涉及。

## 程序

程序主要包含1个头文件（head.h）和4个源文件（main_mpi_mc.cpp, ising.cpp, networks.cpp, common.cpp）。

头文件主要包含库文件引用，常量和全局变量的声明以及main函数所需函数的声明。

源文件分别为
- main_mpi_mc.cpp: 主函数。
- ising.cpp: 伊辛模型的模拟，采样和样本保存。
- networks.cpp: 样本之间距离的计算和网络构建。
- common.cpp: 两个公用的随机数生成函数。

以下将对源文件中重要复杂的函数进行介绍，简单直接的函数(如动态内存)不做讨论

### commmon.cpp
略。

### ising.cpp
- `ComputeNeighbors()`：计算不同伊辛模型在周期性边界条件下的相邻元素矩阵，并存放在`nearest_neighbor`中。目前支持的伊辛模型有二维正常晶格，三角晶格，蜂巢晶格和三维正常晶格（三维晶格只支持蒙特卡罗模拟，并未测试过网络计算相关部分，因此程序有效性不能得到保证）。通过变量`g_ising_mode`判断晶格类型。
- `Metropolis()`和`Wolff()`：分别代表两种蒙特卡罗算法。
- `InitializeIsing()`：初始化。
- `SampleConfiguration()`：采样主函数，采取一定数目的平衡态样本。方法为
    1. `InitializeIsing()`和`ComputeNeighbors()`；
    2. 重复使用蒙特卡罗模拟，由于在相变点附近，使用`Wolff()`，按一定间隔采样。
    3. 删除动态内存。
- `MonteCarloWolff()`：用于蒙特卡罗模拟伊辛模型计算能量，磁化强度等物理量，检测程序正确性。

### networks.cpp
- `Initialize()`, `InitializeOptimized()`, `InitializeMC()`：程序中总共包含三个初始化函数，实际功能均为初始化计算相关变量和计算所需要的样本之间的距离。实际上使用的是第三个`InitializeMC()`。三者的区别于算法部分提到的距离优化方法相关
    - `Initialize()`：只将距离计算优化为內积计算。
    - `InitializeOptimized()`：将內积计算使用异或优化。
    - `InitializeMC()`：同时包含內积异或优化和随机网络蒙特卡罗方法。
- `QuicksortDist()`和`SelectPivot()`：快速排序函数。考虑到內积可能存在重复，对于含重复元素快速排序进行了一定的优化。
- `Update*()`：各种更新变量的函数，具体功能见函数名。
- `BuildNetwork()`：网络构建函数，根据排序好的距离逐渐连边，并计算大团尺寸，并返回所需要的$\Delta$
- `CalculateDelta()`和`CalculateDeltaMC()`：网络部分主函数，方法均为
    1. 动态内存生成和初始化(根据情况使用不同初始化函数)；
    2. `QuicksortDist()`排序；
    3. `BuildNetwork()`构建网络；
    4. 删除动态内存，返回$\Delta$。

    两者的区别为，`CalculateDelta()`调用初始化函数`InitializeOptimized()`,而`CalculateDeltaMC()`调用初始化函数`InitializeMC()`。并且由于使用了二次蒙特卡罗使得随机性更大，因此`CalculateDeltaMC()`进行了更多次的重复求平均，但速度还是远胜于`CalculateDelta()`。

### main_mpi_mc.cpp
- `main()`: 主函数主要功能是设定需要计算的伊辛模型的类型和尺寸，还有温度范围。之后对每种情况进行循环，计算并将结果输出。相应参数均在此修改。其方法为
    1. MPI初始化，相关参数设定和动态内存初始化；
    2. `SampleConfiguration()`采样；
    3. `CalculateDeltaMC()`构建网络并计算$\Delta$；
    4. 各线程结果汇总，输出结果并删除动态内存。

至于各函数具体的实现，详见代码及注释。
